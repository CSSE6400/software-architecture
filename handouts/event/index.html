Last Updated on 2023/03/16      

<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head> <title>Event-Driven Architecture</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<!-- fn-in,html,htex4ht,xhtml --> 
<meta name="src" content="main.tex" /> 
<link rel="stylesheet" type="text/css" href="main.css" /> 
<link rel="stylesheet" href="https://latex.now.sh/style.css"> 
<link rel="stylesheet" href="/notes.css"> 
<style>body {max-width: 100ch;} 
dl dd {text-align: left}</style> 
</head><body 
>
   <div class="maketitle"><a 
 id="Q1-1-1"></a>
_________________________________________________________________________________________________
<h2 class="titleHead">Event-Driven Architecture</h2>                                                          Software Architecture
   <div class="date" >March 27, 2023</div>                                                                                                                                                 <div class="author" >Richard
Thomas</div>
____________________________________________________________________________________________
   </div>
   <h3 class="sectionHead"><span class="titlemark">1    </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 9--><p class="noindent" >Event-driven is an asynchronous architectural style. It reacts to events, which is different to the common
procedural flow of control of many designs where messages are sent as requests. It is a distributed event
handling system, which is conceptually similar to event handling used in many graphical user interface
libraries.
</p><!--l. 13--><p class="indent" >   Events provide a mechanism to manage asynchronous communication. An event is sent to be handled, and
the sender can continue with other tasks while the event is being processed. If necessary, an event
handler can send an asynchronous message back to an event initiator indicating the result of the event
processing.
</p><!--l. 17--><p class="indent" >   Each event handler can be implemented in its own independent execution environment. This allows each
type of handler to be easily scaled to handle its load. Asynchronous communication means that event
generators do not need to wait for the handler to process the event. Handlers can generate their own
events to indicate what they have done. These events can be used to coordinate steps in a business
process.
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                                                    
                                                                                                    
<a 
 id="x1-1001r1"></a>
                                                                                                    
                                                                                                    
<dl class="list1"><dt class="list">
</dt><dd 
class="list">
<!--l. 24--><p class="noindent" ><img 
src="diagrams/conceptual-architecture.png" alt="PIC"  
width="567" height="567"  /></p></dd></dl>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;1: </span><span  
class="content">Conceptual deployment structure of an event-driven architecture.</span></div><!--tex4ht:label?: x1-1001r1 -->
                                                                                                    
                                                                                                    
   </div><hr class="endfigure" />
<!--l. 32--><p class="indent" >   Figure <a 
href="#x1-1001r1">1<!--tex4ht:ref: fig:conceptual-architecture --></a> shows the conceptual structure of an event-driven architecture. A client of some form sends the
initiating event to a central event broker or mediator. That event is picked up by an event handler that processes
the event. That may lead to the event handler generating a processing event to move to the next step of the
process. The processing event is sent to the central broker and is picked up by another event handler. This
continues until the business process is completed.
</p><!--l. 40--><p class="indent" >   An auction system, as shown in figure <a 
href="#x1-1002r2">2<!--tex4ht:ref: fig:auction-architecture --></a>, could be implemented as an event-driven architecture.
</p>
      <ul class="itemize1">
      <li class="itemize">
      <!--l. 42--><p class="noindent" >When a customer bids on an item, they initiate a bid <span 
class="Cabin-Italic-tlf-t1-x-x-120">event</span>.
      </p></li>
      <li class="itemize">
      <!--l. 43--><p class="noindent" >Upon receiving the bid event, the event broker notifies the bid handler, which checks the bid against
      the current high bid and determines the new high bid.
      </p></li>
      <li class="itemize">
      <!--l. 44--><p class="noindent" >The bid handler generates a new high bid event.
      </p></li>
      <li class="itemize">
      <!--l. 45--><p class="noindent" >The event broker notifies the page update handler of the high bid event, which sends the new high
      bid to all pages displaying the item.
      </p></li>
      <li class="itemize">
      <!--l. 46--><p class="noindent" >The bid notification handler is also notified of the high bid event and it sends an email to the bidder
      with the result of their bid.
      </p></li>
      <li class="itemize">
      <!--l. 47--><p class="noindent" >And, the rebid notification handler is also notified of the high bid event. If the previous high bidder
      is no longer the high bidder, they are sent an email asking if they would like to make another bid.</p></li></ul>
   <hr class="figure" /><div class="figure" 
>
                                                                                                    
                                                                                                    
<a 
 id="x1-1002r2"></a>
                                                                                                    
                                                                                                    
<dl class="list1"><dt class="list">
</dt><dd 
class="list">
<!--l. 52--><p class="noindent" ><img 
src="diagrams/auction-architecture.png" alt="PIC"  
width="567" height="567"  /></p></dd></dl>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;2: </span><span  
class="content">Auction bidding example event-driven architecture.</span></div><!--tex4ht:label?: x1-1002r2 -->
                                                                                                    
                                                                                                    
   </div><hr class="endfigure" />
<!--l. 60--><p class="indent" >   There are two basic approaches to implementing an event-driven architecture. They have different high-level
structures or <span 
class="Cabin-Italic-tlf-t1-x-x-120">topologies</span>. The <span 
class="Cabin-Italic-tlf-t1-x-x-120">broker topology </span>is the simpler of the two and is optimised for performance,
responsiveness, scalability, extensibility, fault tolerance, and low coupling. The <span 
class="Cabin-Italic-tlf-t1-x-x-120">mediator topology </span>is more complex
but is designed to provide process control, error handling, and recoverability.
</p>
   <h3 class="sectionHead"><span class="titlemark">2    </span> <a 
 id="x1-20002"></a>Broker Topology</h3>
<!--l. 68--><p class="noindent" >The broker topology consists of five elements.
</p><!--l. 71--><p class="indent" >
      </p><dl class="description"><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Initiating Event</span> </dt><dd 
class="description">
      <!--l. 71--><p class="noindent" >starts the flow of events.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Broker</span> </dt><dd 
class="description">
      <!--l. 72--><p class="noindent" >has <span 
class="Cabin-Italic-tlf-t1-x-x-120">event channels </span>that receive events waiting to be handled.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Channel</span> </dt><dd 
class="description">
      <!--l. 73--><p class="noindent" >holds events waiting to be processed by an event handler.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Handler</span> </dt><dd 
class="description">
      <!--l. 74--><p class="noindent" >accepts and processes events.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Processing Event</span> </dt><dd 
class="description">
      <!--l. 75--><p class="noindent" >sent by an event handler when it has finished processing an event.</p></dd></dl>
   <hr class="figure" /><div class="figure" 
>
                                                                                                    
                                                                                                    
<a 
 id="x1-2001r3"></a>
                                                                                                    
                                                                                                    
<dl class="list1"><dt class="list">
</dt><dd 
class="list">
<!--l. 81--><p class="noindent" ><img 
src="diagrams/broker-components.png" alt="PIC"  
width="579" height="579"  /></p></dd></dl>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;3: </span><span  
class="content">Basic broker topology.</span></div><!--tex4ht:label?: x1-2001r3 -->
                                                                                                    
                                                                                                    
   </div><hr class="endfigure" />
<!--l. 89--><p class="indent" >   In figure <a 
href="#x1-2001r3">3<!--tex4ht:ref: fig:broker-components --></a>, the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Client </span>sends the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Initiating Event </span>to the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Initiating Event Channel </span>in the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Broker</span>. <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler A</span>
accepts the event and processes it. Upon completion of handling the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Initiating Event</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler A</span>
sends <span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 1 </span>to the appropriate channel in the event broker. <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handlers B </span>and <span 
class="Cabin-Italic-tlf-t1-x-x-120">C </span>accept
this processing event and perform their actions. When <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler C </span>finishes processing it sends
<span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 2 </span>to its channel. No event handler is designed to accept <span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 2</span>, so it is
ignored.
</p><!--l. 97--><p class="indent" >   Different event channels in the event broker provide a simple mechanism to coordinate the flow of events in a
business process. As shown in figure <a 
href="#x1-2001r3">3<!--tex4ht:ref: fig:broker-components --></a>, there is a separate channel for each type of event. This allows event
handlers to register to be notified of only the type of events they can process. This reduces the overhead of
broadcasting events to handlers that cannot process them. The consequence is that event sources need to send
their events to the correct channel. For a simple broker topology, this could be by sending event messages directly
to a channel or, for better abstraction and reduced coupling, the event broker may implement a façade that
directs events to the correct channel.
<a 
 id="x1-2002r1"></a>
</p>
   <div class="tcolorbox tcolorbox" id="tcolobox-1">    
<div class="tcolorbox-title">
   </div> 
<div class="tcolorbox-content"><!--l. 106--><p class="noindent" ><span 
class="Cabin-Bold-tlf-t1-x-x-120">Definition</span><span 
class="Cabin-Bold-tlf-t1-x-x-120">&#x00A0;1. Event Handler Cohesion Principle</span>
</p><!--l. 107--><p class="noindent" >Each event handler is a simple cohesive unit that performs a single processing task. </p> 
</div> 
</div>
<!--l. 110--><p class="indent" >   The <span 
class="Cabin-Italic-tlf-t1-x-x-120">event handler cohesion principle </span>minimises the complexity of each handler, and improves the ability of the
system to scale only the tasks that need additional computing resources.
<a 
 id="x1-2003r2"></a>
</p>
   <div class="tcolorbox tcolorbox" id="tcolobox-2">    
<div class="tcolorbox-title">
   </div> 
<div class="tcolorbox-content"><!--l. 114--><p class="noindent" ><span 
class="Cabin-Bold-tlf-t1-x-x-120">Definition</span><span 
class="Cabin-Bold-tlf-t1-x-x-120">&#x00A0;2. Event Handler Independence Principle</span>
</p><!--l. 115--><p class="noindent" >Event handlers should not depend on the implementation of any other event handler. </p> 
</div> 
</div>
<!--l. 118--><p class="indent" >   Dependencies between event handlers limit the processing throughput of the system, and increases the
complexity of implementing event handlers. The only dependency should be the event that is processed by the
event handler.
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.1    </span> <a 
 id="x1-30002.1"></a>Extensibility</h4>
<!--l. 124--><p class="noindent" >There may be multiple event handlers for a single type of event, shown by <span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 1 </span>being sent to both
<span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler B </span>and <span 
class="Cabin-Italic-tlf-t1-x-x-120">C </span>in figure <a 
href="#x1-2001r3">3<!--tex4ht:ref: fig:broker-components --></a>. This allows more than one action to be performed when an event is sent. This
means that new event handlers can be added to the system as it evolves. A new feature can be added
by implementing an event handler to do something new when an event is received by the event
broker.
</p><!--l. 130--><p class="indent" >   In figure <a 
href="#x1-2001r3">3<!--tex4ht:ref: fig:broker-components --></a>, when <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler C </span>finishes processing its event it sends <span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 2 </span>to the
event broker. The diagram indicates that the system does not handle the event. The purpose of doing
this is to make it easier to extend the system. Currently, the system may not need to do anything
when <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler C </span>finishes processing, but because it sends an event to indicate it has finished it
means other tasks can be added to the system following <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler C</span>. Because event handlers are
independent of each other, <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler C </span>does not need to be modified to cater for this later addition of
functionality.
</p><!--l. 137--><p class="indent" >   If there are events that are not handled by the system, the event broker façade can ignore them, it does not
need a channel to manage them. If the system is extended and needs to process one of the ignored events, the
event broker can create a new channel to manage them.
</p><!--l. 140--><p class="indent" >   <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler B</span>, in figure <a 
href="#x1-2001r3">3<!--tex4ht:ref: fig:broker-components --></a>, does not send an event when it finishes processing the event it accepted. This is a
valid design choice when implementing the system, if there is nothing foreseeable that might need to know when
                                                                                                    
                                                                                                    
<span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler B </span>is finished processing. The drawback is that if the system later needs to do something else when
<span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Handler B </span>is finished, it will need to be modified to send an event to the event broker. The tradeoff is
reducing asynchronous communication traffic with unnecessary events, versus providing easy extensibility
later.
</p><!--l. 147--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.2    </span> <a 
 id="x1-40002.2"></a>Scalability</h4>
<!--l. 149--><p class="noindent" >As was mentioned in section <a 
href="#x1-10001">1<!--tex4ht:ref: sec:intro --></a>, the broker topology is optimised for performance. Each event handler is a separate
container that can be deployed independently of other handlers. A load balancer and an automated scaling
mechanism ensures that each event handler can scale to manage its load.
</p><!--l. 153--><p class="indent" >   There may be multiple clients sending events to be processed, and each event handler may itself be a source
of events. This requires the event broker and its channels be able to handle the event traffic load. The event broker
itself can be deployed on multiple compute nodes, with its own load balancing and auto-scaling. The challenge is
to implement this in such a way that the event handlers do not need to know about the event broker&#8217;s
deployment structure.
</p><!--l. 159--><p class="indent" >   A simple distributed event broker could deploy each channel on a separate compute node. The event
broker façade is deployed on its own node and manages receiving events and sending them to the
appropriate channel. The façade also manages how event handlers register to receive notification of
events from channels. This works until the event traffic to the façade or a single channel exceeds their
capacity.
</p><!--l. 164--><p class="indent" >   A more robust approach, which scales to very high traffic levels, is to federate the event broker. This
allows the façade and channels to be distributed across multiple nodes but provides an interface that
the clients and event handlers can treat as a single access point. The complexity of implementing
a federated computing system is beyond the scope of this course. There are several libraries (e.g.
<a 
href="https://activemq.apache.org/" >ActiveMQ</a><span class="footnote-mark"><a 
href="#fn1x0" id="fn1x0-bk"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-4001f1"></a> or
<a 
href="https://www.rabbitmq.com/" >RabbitMQ</a><span class="footnote-mark"><a 
href="#fn2x0" id="fn2x0-bk"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-4003f2"></a>) and cloud-computing
platforms (e.g. <a 
href="https://aws.amazon.com/sqs/" >AWS SQS</a><span class="footnote-mark"><a 
href="#fn3x0" id="fn3x0-bk"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-4005f3"></a>,
<a 
href="https://aws.amazon.com/amazon-mq/" >AWS MQ</a><span class="footnote-mark"><a 
href="#fn4x0" id="fn4x0-bk"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-4007f4"></a> or <a 
href="https://cloud.google.com/pubsub/docs/overview" >Google
Cloud Pub/Sub</a><span class="footnote-mark"><a 
href="#fn5x0" id="fn5x0-bk"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-4009f5"></a>)
that provide this functionality. They can still be used when the system does not need to scale to a federated event
broker, as they provide the underlying implementation for the event broker.
</p><!--l. 175--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.3    </span> <a 
 id="x1-50002.3"></a>Queues</h4>
<!--l. 177--><p class="noindent" >The other issue that the channels need to manage to allow scalability is holding events until they are processed by
an event handler. The simple approach is that a channel implements a queue. Events are added to the end of the
queue as they are received. When an event reaches the front of the queue, all the event handlers for the channel
are notified that the event is available. The channel queue needs to be configured to cater for different
implementation choices. The simple option is that when an event handler accepts the event, it is removed from
the queue. This means that only one type of event handler listening to the channel will process the
event.
</p><!--l. 185--><p class="indent" >   If the system needs all the different types of event handlers to process the event, the queue needs to be
configured so that the event is not removed from the queue until all the event handlers have retrieved it. This can
be implemented in the queue by having multiple <span 
class="Cabin-Italic-tlf-t1-x-x-120">front of queue pointers</span>, one for each type of event
handler listening to the channel. This allows different event handlers to process through events in the
                                                                                                    
                                                                                                    
queue at different rates. The queue should be implemented to pass queue size or the amount of time
events are in the queue to the auto-scaling mechanism for each event handler. This can be used as
part of the logic to determine when to deploy new event handlers, or to scale-back when traffic
decreases.
</p><!--l. 192--><p class="indent" >   To increase reliability, the queue can be implemented to only remove the event from the queue once the
event handler has finished processing it, rather than when it has been received by the handler. This allows another
event handler to process the event if the first event handler to accept the event fails. A timeout mechanism
can be used to provide this functionality. If the queue does not receive notification that the event
has been processed within a certain amount of time, it notifies the event handlers that the event is
available.
</p><!--l. 199--><p class="indent" >   Another consideration to increase reliability is dealing with when the event broker, or one of its queues, fails. If
queues are implemented as in-memory queues, events in the queue will be lost when the event broker or queue
fails. Queues can be implemented to persistently store events until they have been processed. A federated event
broker will further improve reliability by making it less likely that a single queue will fail between receiving an event
and storing it persistently.
</p><!--l. 204--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.4    </span> <a 
 id="x1-60002.4"></a>Streams</h4>
<!--l. 206--><p class="noindent" >An alternative to channels using queues to manage events, is to use streams instead. Event sources send events to
the event broker and they are added to the appropriate stream. Each channel becomes a stream and events are
added to the stream. The observer pattern is used where the channel is the subject and the event handlers are
the observers. When an event is added to a stream, the channel notifies all its observers that an
event has been added. The event handlers then decide whether to retrieve the event and process
it.
</p><!--l. 213--><p class="indent" >   The most important difference of using streams versus queues is that the events are stored permanently in the
stream. Event handlers can process events at their own pace. Because the events are stored permanently, history
is maintained. This allows the system to go back and redo past processing or for an audit to be conducted of what
happened during processing.
</p><!--l. 218--><p class="noindent" >
</p>
   <h4 class="subsectionHead"><span class="titlemark">2.5    </span> <a 
 id="x1-70002.5"></a>Queues vs. Streams</h4>
<!--l. 220--><p class="noindent" >Queues work well when there are known steps in the business process being implemented. Queues ensure that all
preceding events in the business process are completed before the next step. Queues can ensure that events are
only processed once (known as &#8220;exactly once&#8221; semantics). An ecommerce website is an example of the type of
system suited to using queues. This is because there is a fixed set of rules about which event handlers process
which events.
</p><!--l. 226--><p class="indent" >   Streams work well when there are multiple event handlers responding to events, particularly when event
handlers may choose to ignore some events based on various conditions. Streams mean that the event broker or
channels do not need to be notified if an event handler wants to ignore an event. Because streams store events
permanently, data analysis of the system&#8217;s behaviour can be done by processing past events. Streams work well
for social media platforms as monetisation of the platform depends on analysing user behaviour. If
user generated events are stored permanently in streams, new analyses can be performed on past
data.
</p><!--l. 233--><p class="indent" >   Streams also work well for systems that generate a vast number of events, or that have a large
number of event handlers. A health monitoring system, taking advantage of the <a 
href="https://www.oracle.com/au/internet-of-things/what-is-iot/" >Internet of
                                                                                                    
                                                                                                    
Things</a><span class="footnote-mark"><a 
href="#fn6x0" id="fn6x0-bk"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-7001f6"></a>
(IoT), would be an example of such a system. There could be a very large number of monitoring devices that
generate frequent events to notify the system of physiology changes. Streams make it practical to process
different events at an appropriate pace. Some events may need almost immediate processing (e.g. a monitor
reporting heart failure). Other events may need periodic processing (e.g. analysing patient blood pressure over a
period of time). Streams can accept and store events and different event handlers can be optimised for how they
process data in the stream.
</p><!--l. 243--><p class="indent" >   The health monitoring system would also have a large number of event handlers, because many devices
would process some events (e.g. a heart rate display or a patient alarm). Streams have less overhead
to manage their events, so can more easily cope with many event handlers retrieving events for
processing.
</p><!--l. 247--><p class="indent" >   Streams also enable <span 
class="Cabin-Italic-tlf-t1-x-x-120">event sourcing </span>as a persistence mechanism. Event sourcing stores every event, and its
associated state, rather than storing and updating system state. This makes it easier to analyse how the system is
used and what changes happen to the state over time.
</p><!--l. 264--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">3    </span> <a 
 id="x1-80003"></a>Mediator Topology</h3>
   <hr class="figure" /><div class="figure" 
>
                                                                                                    
                                                                                                    
<a 
 id="x1-8001r4"></a>
                                                                                                    
                                                                                                    
<dl class="list1"><dt class="list">
</dt><dd 
class="list">
<!--l. 267--><p class="noindent" ><img 
src="diagrams/mediator-components.png" alt="PIC"  
width="579" height="579"  /></p></dd></dl>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;4: </span><span  
class="content">Basic mediator topology.</span></div><!--tex4ht:label?: x1-8001r4 -->
                                                                                                    
                                                                                                    
   </div><hr class="endfigure" />
<!--l. 275--><p class="indent" >   The mediator topology extends the broker topology by adding an <span 
class="Cabin-Italic-tlf-t1-x-x-120">event mediator</span>. The event mediator
manages the flow of events to implement the business process. There are six elements that make up the mediator
topology.
      </p><dl class="description"><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Initiating Event</span> </dt><dd 
class="description">
      <!--l. 280--><p class="noindent" >starts the flow of events.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Queue</span> </dt><dd 
class="description">
      <!--l. 281--><p class="noindent" >holds initiating events sent to the event mediator.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Mediator</span> </dt><dd 
class="description">
      <!--l. 282--><p class="noindent" >coordinates sending events to the event handlers to implement a business process.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Processing Event</span> </dt><dd 
class="description">
      <!--l. 283--><p class="noindent" >sent by the event mediator to start the next step in the process.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Handler</span> </dt><dd 
class="description">
      <!--l. 284--><p class="noindent" >accepts and processes events.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Event Channel</span> </dt><dd 
class="description">
      <!--l. 285--><p class="noindent" >holds events waiting to be processed by an event handler.</p></dd></dl>
<!--l. 288--><p class="indent" >   In figure <a 
href="#x1-8001r4">4<!--tex4ht:ref: fig:mediator-components --></a>, the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Client </span>sends the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Initiating Event </span>to the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Queue</span>. The <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Queue </span>notifies the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator</span>
that an event has been enqueued. The <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator </span>dequeues the next <span 
class="Cabin-Italic-tlf-t1-x-x-120">Initiating Event </span>and starts the business
process to deliver the behaviour for that event. The <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator </span>adds a <span 
class="Cabin-Italic-tlf-t1-x-x-120">Processing Event 1 </span>to its channel. The
channel notifies the event handlers listening for this type of event. The event handlers retrieve the event from the
channel and process it.
</p><!--l. 295--><p class="indent" >   When an event handler finishes processing it does not send a processing event to the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator </span>to be
handled. Rather, the event handler usually sends an asynchronous message to the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator </span>indicating that
the handler has finished processing. When the <span 
class="Cabin-Italic-tlf-t1-x-x-120">Event Mediator </span>receives a completion message from an event
handler, the mediator determines what is the next step in the process and sends a processing event to the
appropriate channel to continue the logic.
</p><!--l. 300--><p class="indent" >   The event mediator allows the system to implement more sophisticated logic to deliver the business process.
Based on the result received from an event handler, when it finishes processing an event, the mediator can decide
which processing event to send next. This allows conditional or iterative logic to be implemented in the business
process. Unlike the broker topology, which only has a sequential flow through the business logic based on event
handlers sending new events when they finish processing.
</p>
   <h4 class="subsectionHead"><span class="titlemark">3.1    </span> <a 
 id="x1-90003.1"></a>Implementation</h4>
<!--l. 308--><p class="noindent" >Commonly, the mediator topology will implement multiple event mediators. Each one deals with a subset of
events. These are usually related to a particular part of the problem domain. For example, in the Sahara
eCommerce system, there could be event mediators for:
                                                                                                    
                                                                                                    
      </p><dl class="description"><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Customer Events</span> </dt><dd 
class="description">
      <!--l. 313--><p class="noindent" >&#8211; registering, updating profile, viewing order history, ...
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Browsing Events</span> </dt><dd 
class="description">
      <!--l. 314--><p class="noindent" >&#8211; searching, browsing by category, requesting product detail, ...
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Order Events</span> </dt><dd 
class="description">
      <!--l. 315--><p class="noindent" >&#8211; adding product to shopping cart, checking out, cancel order, ...
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Inventory Events</span> </dt><dd 
class="description">
      <!--l. 316--><p class="noindent" >&#8211; viewing inventory levels, reporting on popular products, ordering new stock, ...</p></dd></dl>
<!--l. 318--><p class="noindent" >This allows different mediators to be scaled independently, based on their load. It also improves reliability, as one
mediator can fail but others can continue to operate.
</p><!--l. 321--><p class="indent" >   Like with the broker topology, there are many libraries and cloud-computing platforms that support
implementing the mediator topology. Different libraries focus on different aspects of event coordination within
the event mediator.
</p><!--l. 324--><p class="indent" >   If the event coordination and error handling that needs to be implemented are relatively
simple, it is often easiest to implement the logic in code. Libraries such as <a 
href="https://camel.apache.org/" >Apache
Camel</a><span class="footnote-mark"><a 
href="#fn7x0" id="fn7x0-bk"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-9001f7"></a> or <a 
href="https://spring.io/projects/spring-integration" >Spring
Integration</a><span class="footnote-mark"><a 
href="#fn8x0" id="fn8x0-bk"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-9003f8"></a>,
provide the messaging infrastructure to support this type of implementation.
</p><!--l. 330--><p class="indent" >   If the event coordination and error handling are fairly complex, involving a lot of complex conditional
processing or dynamic path determination with complex error handling, it is often easier to use a declarative
DSL<span class="footnote-mark"><a 
href="#fn9x0" id="fn9x0-bk"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-9005f9"></a>
to implement the logic. One such language is <a 
href="https://www.oracle.com/technical-resources/articles/matjaz-bpel.html" >Business Process Execution
Language</a><span class="footnote-mark"><a 
href="#fn10x0" id="fn10x0-bk"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-9007f10"></a>
(BPEL). It describes the steps involved in processing an event, along with error
handling, multicasting and other features. Libraries such as Oracle&#8217;s <a 
href="https://www.oracle.com/middleware/technologies/bpel-process-manager.html" >BPEL Process
Manager</a><span class="footnote-mark"><a 
href="#fn11x0" id="fn11x0-bk"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-9009f11"></a>,
provide infrastructure to support the description and execution of the process.
</p><!--l. 338--><p class="indent" >   BPEL is not suited to event coordination and error handling that may require human
intervention, due to the long run times of this type of processing. A more sophisticated Business
Process Management (BPM) execution engine may be more appropriate in this context. These
engines use multiple DSLs to provide more sophisticated process automation. Libraries such as
<a 
href="https://www.jbpm.org/" >jBPM</a><span class="footnote-mark"><a 
href="#fn12x0" id="fn12x0-bk"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-9011f12"></a>
provide the infrastructure that enable this type of event mediator implementation.
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                                                    
                                                                                                    
<a 
 id="x1-9013r5"></a>
                                                                                                    
                                                                                                    
<dl class="list1"><dt class="list">
</dt><dd 
class="list">
<!--l. 344--><p class="noindent" ><img 
src="diagrams/complex-mediator-components.png" alt="PIC"  
width="579" height="579"  /></p></dd></dl>
<br /> <div class="caption" 
><span class="id">Figure&#x00A0;5: </span><span  
class="content">Complex mediator topology.</span></div><!--tex4ht:label?: x1-9013r5 -->
                                                                                                    
                                                                                                    
   </div><hr class="endfigure" />
<!--l. 352--><p class="indent" >   Figure <a 
href="#x1-9013r5">5<!--tex4ht:ref: fig:complex-mediator-components --></a> is an example of extending the idea of implementing multiple event mediators to have different types
of mediators based on the complexity of the event. This is because most large systems will have a mix of
simple and complex events, and some of the complex events may have long durations. It is usually
more efficient in developer time and effort to apply different strategies for different types of events.
Describing and verifying the process for a simple event using BPEL or a BPM execution engine may cost
more developer effort than implementing the logic programmatically. To minimise coupling, the
client still only sends initiating events to a single event queue. An event mediator retrieves the events
from the event queue and classifies them, adding the events to a queue for the appropriate type of
mediator.
</p>
   <h3 class="sectionHead"><span class="titlemark">4    </span> <a 
 id="x1-100004"></a>Broker vs. Mediator Topologies</h3>
<!--l. 365--><p class="noindent" >One way to think of the differences between the broker and mediator topologies is:
      </p><dl class="description"><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Broker</span> </dt><dd 
class="description">
      <!--l. 367--><p class="noindent" >is a <span 
class="Cabin-Italic-tlf-t1-x-x-120">dumb pipe</span>.
      </p></dd><dt class="description">
<span 
class="Cabin-Bold-tlf-t1-x-x-120">Mediator</span> </dt><dd 
class="description">
      <!--l. 368--><p class="noindent" >is a <span 
class="Cabin-Italic-tlf-t1-x-x-120">smart pipe</span><span class="footnote-mark"><a 
href="#fn13x0" id="fn13x0-bk"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-10001f13"></a>.</p></dd></dl>
<!--l. 372--><p class="indent" >   An event broker only provides a messaging service to notify event handlers of events. The broker does not
control the logic of business process. Consequently, it cannot maintain any state related to the process. It also
cannot perform any error handling if an error occurs in the middle of the process.
</p><!--l. 377--><p class="indent" >   An event mediator coordinates the implementation of the business process by sending events to start each
step of the process. This allows a mediator to implement complex logic. This can include maintaining state for the
process and performing error handling. In the auction example, once a bidder wins an auction they have to pay for
the item. <span 
class="Cabin-Italic-tlf-t1-x-x-120">Pay for item </span>would be the initiating event to begin the process of paying for the item. <span 
class="Cabin-Italic-tlf-t1-x-x-120">Notification sent</span>
and <span 
class="Cabin-Italic-tlf-t1-x-x-120">order fulfilled </span>would be other events in the payment process. If the payment failed, the event mediator
could store the state of the process and once payment was successfully processed it could restart the
process.
</p><!--l. 386--><p class="indent" >   A conceptual difference between the broker and mediator topologies is that the broker topology is a pure form
of event handling. Events represent things that have happened. Once an action has occurred, the event is
published and event handlers react to it. In the auction system, events in a broker topology would be <span 
class="Cabin-Italic-tlf-t1-x-x-120">bid placed</span>,
<span 
class="Cabin-Italic-tlf-t1-x-x-120">new high bid</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">payment started</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">payment accepted</span>, &#x2026;.
</p><!--l. 392--><p class="indent" >   The mediator topology is more like a command driven process. The events are commands sent by
the event mediator to perform the next step in the business process. In the auction system, events
in a mediator topology would be <span 
class="Cabin-Italic-tlf-t1-x-x-120">place bid</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">notify bidders</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">notify previous high bidder</span>, <span 
class="Cabin-Italic-tlf-t1-x-x-120">pay for item</span>,
&#x2026;.
</p><!--l. 397--><p class="indent" >   Consequently, in the broker topology, because events represent actions that have occurred, some events can
be ignored. In the mediator topology, because events are commands to perform the next step in the business
process, they must be executed.
</p><!--l. 400--><p class="noindent" ><span 
class="Cabin-Bold-tlf-t1-x-x-120">Broker Advantages</span>
</p>
                                                                                                    
                                                                                                    
      <ul class="itemize1">
      <li class="itemize">
      <!--l. 404--><p class="noindent" >Greater scalability because the broker just distributes event notifications and does not have state, it
      is easier to federate the broker to provide greater throughput.
      </p></li>
      <li class="itemize">
      <!--l. 406--><p class="noindent" >Greater  reliability  because  the  broker  does  not  coordinate  the  business  process.  If  the  broker  is
      federated and a broker compute node fails, another node can accept the next processing event and
      the process can continue.
      </p></li>
      <li class="itemize">
      <!--l. 408--><p class="noindent" >Lower coupling because the only dependency between parts of the system are the events.</p></li></ul>
<!--l. 411--><p class="noindent" ><span 
class="Cabin-Bold-tlf-t1-x-x-120">Mediator Advantages</span>
</p>
      <ul class="itemize1">
      <li class="itemize">
      <!--l. 415--><p class="noindent" >Allows for more complex business process logic and error handling.
      </p></li>
      <li class="itemize">
      <!--l. 416--><p class="noindent" >Can store process state and restart a process after recovering from an error.</p></li></ul>
<!--l. 419--><p class="indent" >   This is not to say that the mediator topology scales poorly, it is just easier to scale to extreme loads with the
broker topology. The broker topology takes independence to the extreme to reduce coupling. To provide process
control, the mediator topology requires some coupling between the event mediator and the event handlers. The
trade-off to consider is whether the business process logic is complex enough that it is easier to implement with
the mediator topology.
</p><!--l. 424--><p class="indent" >   Reliability versus recoverability is another trade-off to consider. If the event broker is federated and there are
multiple instances of each event handler, it is extremely unlikely that some part of the system will fail and not be
available. But, this does not deal with errors that occur within a business process. The event mediator can recover
from errors and complete a business process.
</p><!--l. 430--><p class="indent" >   It is possible to have a hybrid architecture that uses both broker and mediator topologies. Event mediators can
implement complex business processes in the system. Event brokers can handle events related to simpler
business processes.
</p><!--l. 435--><p class="noindent" >
</p>
   <h3 class="sectionHead"><span class="titlemark">5    </span> <a 
 id="x1-110005"></a>Conclusion</h3>
<!--l. 437--><p class="noindent" >Event-driven architecture enables delivering a highly scalable and extensible distributed system. Implementation
is complex, though this is offset to a certain degree by the availability of libraries or services that implement much
of the event broker or event mediator behaviour. The event handler cohesion and event handler independence
principles help reduce the complexity of the event handlers. It is the event logic coordination, along with
asynchronous communication and inevitable communication failures, that adds to the complexity of the
architecture.
                                                                                                    
                                                                                                    
</p><!--l. 444--><p class="indent" >   Testing and debugging asynchronous communication is a difficult task. The scale of most event-driven
architecture tends to exasperate this difficulty.
</p><!--l. 447--><p class="indent" >   The event-driven architecture can be combined with other architectural styles. This allows other architectures
to take advantage of the scalability and responsiveness of the event-driven approach. Two architectures that
commonly are combined with the event-driven architecture are space-based and microservices. They are not the
only hybrid approaches, many other architectures use or borrow from event-driven (e.g. event-driven
microkernel).
</p>
   <div class="footnotes"><a 
 id="x1-4002x2.2"></a>
<!--l. 168--><p class="indent" >       <span class="footnote-mark"><a 
href="#fn1x0-bk" id="fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
href="https://activemq.apache.org/" class="url" ><span 
class="ectt-1000">https://activemq.apache.org/</span></a></p><a 
 id="x1-4004x2.2"></a>
<!--l. 168--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn2x0-bk" id="fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
href="https://www.rabbitmq.com/" class="url" ><span 
class="ectt-1000">https://www.rabbitmq.com/</span></a></p><a 
 id="x1-4006x2.2"></a>
<!--l. 169--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn3x0-bk" id="fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
href="https://aws.amazon.com/sqs/" class="url" ><span 
class="ectt-1000">https://aws.amazon.com/sqs/</span></a></p><a 
 id="x1-4008x2.2"></a>
<!--l. 170--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn4x0-bk" id="fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
href="https://aws.amazon.com/amazon-mq/" class="url" ><span 
class="ectt-1000">https://aws.amazon.com/amazon-mq/</span></a></p><a 
 id="x1-4010x2.2"></a>
<!--l. 171--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn5x0-bk" id="fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
href="https://cloud.google.com/pubsub/docs/overview" class="url" ><span 
class="ectt-1000">https://cloud.google.com/pubsub/docs/overview</span></a></p><a 
 id="x1-7002x2.5"></a>
<!--l. 235--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn6x0-bk" id="fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
href="https://www.oracle.com/au/internet-of-things/what-is-iot/" class="url" ><span 
class="ectt-1000">https://www.oracle.com/au/internet-of-things/what-is-iot/</span></a></p><a 
 id="x1-9002x3.1"></a>
<!--l. 326--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn7x0-bk" id="fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
href="https://camel.apache.org/" class="url" ><span 
class="ectt-1000">https://camel.apache.org/</span></a></p><a 
 id="x1-9004x3.1"></a>
<!--l. 327--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn8x0-bk" id="fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
href="https://spring.io/projects/spring-integration" class="url" ><span 
class="ectt-1000">https://spring.io/projects/spring-integration</span></a></p><a 
 id="x1-9006x3.1"></a>
<!--l. 332--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn9x0-bk" id="fn9x0"><sup class="textsuperscript">9</sup></a></span><span 
class="Cabin-Regular-tlf-t1-">Domain Specific Language</span></p><a 
 id="x1-9008x3.1"></a>
<!--l. 333--><p class="indent" >        <span class="footnote-mark"><a 
href="#fn10x0-bk" id="fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
href="https://www.oracle.com/technical-resources/articles/matjaz-bpel.html" class="url" ><span 
class="ectt-1000">https://www.oracle.com/technical-resources/articles/matjaz-bpel.html</span></a></p><a 
 id="x1-9010x3.1"></a>
<!--l. 335--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn11x0-bk" id="fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
href="https://www.oracle.com/middleware/technologies/bpel-process-manager.html" class="url" ><span 
class="ectt-1000">https://www.oracle.com/middleware/technologies/bpel-process-manager.html</span></a></p><a 
 id="x1-9012x3.1"></a>
<!--l. 341--><p class="indent" >   <span class="footnote-mark"><a 
href="#fn12x0-bk" id="fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
href="https://www.jbpm.org/" class="url" ><span 
class="ectt-1000">https://www.jbpm.org/</span></a></p><a 
 id="x1-10002x4"></a>
<!--l. 369--><p class="noindent" ><span class="footnote-mark"><a 
href="#fn13x0-bk" id="fn13x0"><sup class="textsuperscript">13</sup></a></span><span 
class="Cabin-Regular-tlf-t1-">This is a corruption of the original usage of &#8220;smart&#8221; pipes, which was related to complex Enterprise Service Buses. Though,</span>
<span 
class="Cabin-Regular-tlf-t1-">using BPEL processors or BPM engines is moving into the same territory of intelligence.</span></p>                                                                        </div>
 
</body></html> 

                                                                                                    


