// Software Architecture notes
@misc{fowler-what-is-architecture,
	author       = {Martin Fowler},
	title        = {Software Architecture Guide},
	howpublished = {\url{https://martinfowler.com/architecture/}},
	month        = {August},
	year         = {2019},
}
@inproceedings{wicked-architecture,
	title        = {What Makes Teaching Software Architecture Difficult?},
	author       = {Galster, Matthias and Angelov, Samuil},
	year         = 2016,
	booktitle    = {Proceedings of the 38th International Conference on Software Engineering Companion},
	location     = {Austin, Texas},
	publisher    = {Association for Computing Machinery},
	series       = {ICSE '16},
	pages        = {356--359},
	doi          = {10.1145/2889160.2889187},
	isbn         = 9781450342056,
	url          = {https://doi.org/10.1145/2889160.2889187},
	numpages     = 4,
	keywords     = {education, learners, training, software architecture, students},
	annotate     = {An article which attempts to enumerate the reasons why teaching software architecture is hard. They coin the term `wicked architecture` to explain the imprecise nature of software architecture that students struggle with.}
}
@misc{martin-principles-patterns,
	author       = {Robert C. Martin},
	title        = {Design Principles and Design Patterns},
	howpublished = {\url{https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles\_and\_Patterns.pdf}},
	year         = {2000},
	annotate     = {Blog post from Uncle Bob's Object Mentor site describing the SOLID design principles.},
	note = "Accessed: 2022-01-10"
}
// ADR notes
@article{kruchten-arch-decisions,
	issn = {0740-7459},
	abstract = {Software development has to deal with many challenges-increasing system complexity, requests for better quality, the burden of maintenance operations, distributed production, and high staff turnover, to name just a few. Increasingly, software companies that strive to reduce their products' maintenance costs demand flexible, easy-to-maintain designs. Software architecture constitutes the cornerstone of software design, key for facing these challenges. Several years after the "software crisis" began in the mid-1970s, software architecture practice emerged as a mature (although still growing) discipline, capable of addressing the increasing complexity of new software systems.},
	journal = {IEEE Software},
	pages = {36--42},
	volume = {26},
	publisher = {IEEE},
	number = {2},
	year = {2009},
	title = {The Decision View's Role in Software Architecture Practice},
	copyright = {Copyright IEEE Computer Society Mar/Apr 2009},
	language = {eng},
	address = {Los Alamitos},
	author = {Kruchten, Philippe and Capilla, Rafael and Duenas, Juan Carlos},
	keywords = {architectural design decision ; architectural knowledge ; Architecture ; architecture views ; Collaborative software ; Computer architecture ; Context modeling ; Costs ; Decision analysis ; decision view ; Intellectual capital ; Production systems ; Software architecture ; Software design ; Software engineering ; Software maintenance ; Software systems ; Standards development ; Studies}
}
@misc{nygard-adr,
	author       = {Michael Nygard},
	title        = {Documenting Architecture Decisions},
	howpublished = {\url{https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions}},
	month        = {November},
	year         = {2011},
	note = "Accessed: 2022-01-27"
}
@misc{y-statement,
	author       = {Olaf Zimmermann},
	title        = {Architectural Decisions -- The Making Of},
	howpublished = {\url{https://ozimmer.ch/practices/2020/04/27/ArchitectureDecisionMaking.html}},
	month        = {March},
	year         = {2021},
	note = "Accessed: 2022-02-02"
}
@misc{why-write-adrs,
	author       = {Eli Perkins},
	title        = {Why Write ADRs},
	howpublished = {\url{https://github.blog/2020-08-13-why-write-adrs/}},
	month        = {August},
	year         = {2020},
	note = "Accessed: 2022-02-02"
}
// Security notes
@misc{security-principles,
	title        = {7 Application Security Principles You Need to Know},
	author       = {Eric Boersma},
	year         = 2020,
	month        = {October},
	howpublished = {\url{https://www.cprime.com/resources/blog/security-by-design-7-principles-you-need-to-know/}},
	annotate     = {A blog post outlining 7 security principles which developers should keep in mind to ensure a secure system.}
}
@article{1975-security-design-principles,
	title        = {The protection of information in computer systems},
	author       = {Saltzer, Jerome H and Schroeder, Michael D},
	year         = 1975,
	month        = {September},
	journal      = {Proceedings of the IEEE},
	publisher    = {IEEE},
	volume       = 63,
	number       = 9,
	pages        = {1278--1308},
	doi          = {10.1109/PROC.1975.9939},
	annotate     = {Early text which is the first (to my knowledge) to enumerate security design principles.}
}
@inbook{1988-security-design-principles,
	title        = {Building a Secure Computer System},
	author       = {Gasser, Morrie},
	year         = 1988,
	month        = {January},
	publisher    = {Van Nostrand Reinhold Company},
	pages        = {35--44},
	isbn         = 9780442230227,
	annotate     = {Another early text which enumerates a collection of security design principles.}
}
@inbook{2001-security-design-principles,
	title        = {Building Secure Software: How to Avoid Security Problems the Right Way},
	author       = {Viega, John and McGraw, Gary R},
	year         = 2001,
	month        = {September},
	publisher    = {Addison-Wesley Professional},
	pages        = {91--113},
	isbn         = 9780672334092,
	annotate     = {A more recent text that also enumerates a number of security design principles.}
}
@inbook{death-taxes-and-failure,
	title        = {Security Principles To Live By},
	author       = {Howard, Michael and LeBlanc, David},
	year         = 2002,
	month        = {December},
	booktitle    = {Writing Secure Code},
	publisher    = {Microsoft Press Redmond, Wash.},
	pages        = 64,
	isbn         = {0735617228},
	annotate     = {Source contains an excellent quote on the principle of failing securely ``Death, taxes, and computer system failure are all inevitable to some degree. Plan for the event.''}
}
@misc{failing-securely,
	title        = {Failing Securely},
	author       = {Gegick, Michael and Barnum, Sean},
	year         = 2005,
	month        = {December},
	publisher    = {Cybersecurity \& Infrastructure Security Agency},
	howpublished = {\url{https://www.cisa.gov/uscert/bsi/articles/knowledge/principles/failing-securely}},
	annotate     = {A page with a collation of relevant expert opinions on failing securely.}
}
@misc{facebook-outage,
	title        = {More details about the {October} 4 outage},
	author       = {Santosh Janardhan},
	year         = 2021,
	month        = {October},
	howpublished = {\url{https://engineering.fb.com/2021/10/05/networking-traffic/outage-details/}},
	annotate     = {A Facebook engineering blog post which explains the cause of an outage and the subsequent challenges caused by failing securely}
}
@article{shannons-maxim,
	title        = {Communication theory of secrecy systems},
	author       = {Shannon, C. E.},
	year         = 1949,
	journal      = {The Bell System Technical Journal},
	volume       = 28,
	number       = 4,
	pages        = {656--715},
	doi          = {10.1002/j.1538-7305.1949.tb00928.x},
	annotate     = {The article where Shannon's maxim ``One ought to design systems under the assumption that the enemy will immediately gain full familiarity with them'' is coined. Shannon's maxim is a particular wording of Kerckhoff's principle.}
}
@misc{password-security,
	title        = {2021 World Password Day: How Many Will Be Stolen This Year?},
	author       = {Sam Manjarres},
	year         = 2021,
	month        = {May},
	howpublished = {\url{https://www.secplicity.org/2021/05/04/2021-world-password-day-how-many-will-be-stolen-this-year/}},
	annotate     = {A number of hopefully alarming facts about password theft and cracking in 2021.}
}
@article{least-privilege,
	title        = {Protection and the Control of Information Sharing in Multics},
	author       = {Saltzer, Jerome H.},
	year         = 1974,
	month        = {July},
	journal      = {Communications of the ACM},
	publisher    = {Association for Computing Machinery},
	volume       = 17,
	number       = 7,
	pages        = {388--402},
	doi          = {10.1145/361011.361067},
	issn         = {0001-0782},
	url          = {https://doi.org/10.1145/361011.361067},
	issue_date   = {July 1974},
	numpages     = 15,
	annotate     = {The article where Saltzer coined the principle of least priviledge, one of the foundations of security design principles.}
}
@misc{color-js,
	author = {Roth, Emma},
	title = {Open source developer corrupts widely-used libraries, affecting tons of projects},
	howpublished = {\url{https://www.theverge.com/2022/1/9/22874949/developer-corrupts-open-source-libraries-projects-affected}},
	month = {January},
	year = {2022},
}
// Layered Architecture notes
@article{ballofmud,
	title        = {Big ball of mud},
	author       = {Foote, Brian and Yoder, Joseph},
	year         = 1997,
	journal      = {Pattern languages of program design},
	volume       = 4,
	pages        = {654--692},
	annotate     = {The source for the term `big ball of mud` used to describe an architecture without intentional style.}
}
@misc{spaghetti-code,
	title        = {How to Avoid Spaghetti Code},
	author       = {Gulsah},
	year         = 2020,
	month        = {November},
	howpublished = {\url{https://tech.zensurance.com/posts/spaghetti-code}},
	annotate     = {A blog post about why spaghetti code gets created and how to avoid creating it.},
	note 	     = {note = ``Accessed: 2022-02-18''}
}
// Pipeline Architecture
@inproceedings{mapreduce,
	title        = {MapReduce: Simplified Data Processing on Large Clusters},
	author       = {Jeffrey Dean and Sanjay Ghemawat},
	year         = 2004,
	booktitle    = {OSDI'04: Sixth Symposium on Operating System Design and Implementation},
	address      = {San Francisco, CA},
	pages        = {137--150}
}
@misc{mapreduce-critique,
	title        = {MapReduce: A major step backwards},
	author       = {David J. DeWitt and Michael Stonebraker},
	year         = 2008,
	month        = {January},
	howpublished = {\url{https://dsf.berkeley.edu/cs286/papers/backwards-vertica2008.pdf}},
	annotate     = {An article which critiques the popularity of the MapReduce pattern.}
}
// Docker notes
@misc{static-hello-world,
	title        = {Smallest x86 {ELF} Hello World},
	author       = {henszey},
	year         = {},
	month        = {},
	howpublished = {\url{http://timelessname.com/elfbin/}},
	annotate     = {A small article which investigates the creation of a small statically linked hello world program.}
}
@misc{docker-from-scratch,
	title        = {Docker: FROM scratch},
	author       = {Changhui Xu},
	year         = 2020,
	month        = {July},
	howpublished = {\url{https://codeburst.io/docker-from-scratch-2a84552470c8}},
	annotate     = {An article detailing the process required for running a statically linked hello world program in the scratch docker environment.}
}
// Views
@article{4+1-model,
	title        = {Architectural blueprints --- the `4+1' view model of software architecture},
	author       = {Kruchten, Philippe},
	year         = 1995,
	journal      = {IEEE Software},
	volume       = 12,
	number       = 6,
	pages        = {42--50},
	note 	 = {\url{https://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf}}
}
// Design Patterns
@misc{observer,
	title        = {Observer},
	author       = {Alexander Shvets},
	year         = {},
	month        = {},
	howpublished = {\url{https://refactoring.guru/design-patterns/observer}},
	annotate     = {Fairly good description of the observer design pattern.},
	note 	 = {note = "Accessed: 2022-02-18"}
}
// Examples
@misc{faa-aas,
	title        = {Federal Aviation Administration (FAA) Advanced Automation System (AAS)},
	author       = {Tom Hilburn and Alice Squires and Heidi Davidz and Richard Turner},
	year         = {2021},
	month        = {October},
	howpublished = {\url{https://www.sebokwiki.org/wiki/Federal_Aviation_Administration_(FAA)_Advanced_Automation_System_(AAS)}},
	annotate     = {A small article which investigates the creation of a small statically linked hello world program.},
	note 	 = {Example from the \textit{Guide to the Systems Engineering Body of Knowledge} \url{https://www.sebokwiki.org/w/index.php?title=Guide_to_the_Systems_Engineering_Body_of_Knowledge_(SEBoK)&oldid=63222}}
}
// DevOps
@misc{AWS-DevOps,
	title        = {What is {DevOps}?},
	author       = {AWS},
	year         = {},
	month        = {},
	howpublished = {\url{https://aws.amazon.com/devops/what-is-devops/}},
	annotate     = {Brief summary of DevOps practices.},
}
@misc{AWS-DevOps-Tools,
	title        = {{DevOps} and {AWS}: Tooling and infrastructure resources for {DevOps} practitioners},
	author       = {AWS},
	year         = {},
	month        = {},
	howpublished = {\url{https://aws.amazon.com/devops/}},
	annotate     = {Brief summary of AWS DevOps tools.},
}
@article{CallananMatt2016DMIE,
issn = {0740-7459},
abstract = {Wotif Group used DevOps principles to recover from the downward spiral of manual release activity that many IT departments face. Its approach involved the idea of "making it easy to do the right thing." By defining the right thing (deployment standards) for development and operations teams and making it easy to adopt, Wotif drastically improved the average release cycle time. This article is part of a theme issue on DevOps.},
journal = {IEEE Software},
pages = {53--59},
volume = {33},
publisher = {IEEE},
number = {3},
year = {2016},
title = {{DevOps}: Making It Easy to Do the Right Thing},
copyright = {Copyright 2017 Elsevier B.V., All rights reserved.},
language = {eng},
address = {LOS ALAMITOS},
author = {Callanan, Matt and Spillane, Alexandra},
keywords = {Automation ; Computer Science ; Computer Science, Software Engineering ; continuous delivery ; continuous deployment ; DevOps ; e-commerce ; Internet ; Product development ; Production processes ; Science \& Technology ; Software delivery ; Software development ; Software engineering ; software release ; software release management and delivery ; Standards ; Studies ; Technology ; Testing ; Travel agencies ; Wotif Group},
}
@inproceedings{SenapathiMali2018DCPa,
series = {EASE'18},
abstract = {DevOps is a set of principles and practices to improve collaboration between development and IT Operations. Against the backdrop of the growing adoption of DevOps in a variety of software development domains, this paper describes empirical research into factors influencing its implementation. It presents findings of an in-depth exploratory case study that explored DevOps implementation in a New Zealand product development organisation. The study involved interviewing six experienced software engineers who continuously monitored and reflected on the gradual implementation of DevOps principles and practices. For this case study the use of DevOps practices led to significant benefits, including increase in deployment frequency from about 30 releases a month to an average of 120 releases per month, as well as improved natural communication and collaboration between IT development and operations personnel. We found that the support of a number of technological enablers, such as implementing an automation pipeline and cross functional organisational structures, were critical to delivering the expected benefits of DevOps.},
pages = {57--67},
volume = {137700},
publisher = {ACM},
booktitle = {Proceedings of the 22nd International Conference on evaluation and assessment in software engineering 2018},
isbn = {1450364039},
year = {2018},
title = {{DevOps} Capabilities, Practices, and Challenges: Insights from a Case Study},
copyright = {Copyright 2018 Elsevier B.V., All rights reserved.},
language = {eng},
author = {Senapathi, Mali and Buchan, Jim and Osman, Hady},
keywords = {Challenges ; Computer Science - Software Engineering ; DevOps benefits ; DevOps benefits and challenges ; DevOps enablers ; DevOps enablers and practices ; Practices},
}
// Distributed Systems I
@ARTICLE{therac,
  author={Leveson, N.G. and Turner, C.S.},
  journal={Computer}, 
  title={An investigation of the Therac-25 accidents}, 
  year={1993},
  volume={26},
  number={7},
  pages={18-41},
  doi={10.1109/MC.1993.274940}
}
@inproceedings{neumann-faults,
  title={Probabilistic logics and synthesis of reliable organisms from unreliable components, Automata Studies},
  author={von Neumann, John},
  journal={Annals of Mathematical Studies},
  volume={34},
  pages={43--98},
  year={1956}
}
@misc{four-fallacies,
	author = {Ingrid Van Den Hoogen},
	title = {Deutsch's Fallacies, 10 Years After},
	howpublished = {\url{https://web.archive.org/web/20070811082651/http://java.sys-con.com/read/38665.htm}},
	month = {January},
	year = {2004},
}
@misc{eight-fallacies,
	author = {Peter Jausovec},
	title = {Fallacies of distributed systems},
	howpublished = {\url{https://blogs.oracle.com/developers/post/fallacies-of-distributed-systems}},
	month = {November},
	year = {2020},
}
// Distributed Systems III
@misc{retry-pattern,
	author = {Rahul Rajat Singh},
	title = {Understanding Retry Pattern With Exponential Back-Off and Circuit Breaker Pattern},
	howpublished = {\url{https://dzone.com/articles/understanding-retry-pattern-with-exponential-back}},
	month = {October},
	year = {2016},
}
@misc{backoff-jitter,
	author = {Marc Brooker},
	title = {Exponential Backoff and Jitter},
	howpublished = {\url{https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/}},
	month = {March},
	year = {2015},
}
@article{LamportLeslie1978Tcat,
issn = {0001-0782},
abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
journal = {Communications of the ACM},
pages = {558--565},
volume = {21},
publisher = {ACM},
number = {7},
year = {1978},
title = {Time, clocks, and the ordering of events in a distributed system},
copyright = {Copyright 2004 Elsevier B.V., All rights reserved.},
language = {eng},
author = {Lamport, Leslie},
keywords = {clock synchronization ; computer networks ; distributed systems ; multiprocess systems},
}
@article{BrewerE2012Ctyl,
issn = {0018-9162},
abstract = {The CAP theorem asserts that any networked shared-data system can have only two of three desirable properties. However, by explicitly handling partitions, designers can optimize consistency and availability, thereby achieving some trade-off of all three. The featured Web extra is a podcast from Software Engineering Radio, in which the host interviews Dwight Merriman about the emerging NoSQL movement, the three types of nonrelational data stores, Brewer's CAP theorem, and much more.},
  author={Brewer, Eric},
  journal={Computer}, 
  title={CAP twelve years later: How the "rules" have changed}, 
  year={2012},
  volume={45},
  number={2},
  pages={23-29},
  doi={10.1109/MC.2012.37},
  keywords = {ACID ; BASE ; CAP theorem ; Cloud computing ; Data processing ; Distributed databases ; Relational databases},
}
@misc{rfc677,
	author = {Paul R. Johnson and Robert H. Thomas},
	title = {RFC 677: The Maintenance of Duplicate Databases},
	publisher = {Internet Engineering Task Force: Network Working Group},
	howpublished = {\url{https://www.ietf.org/rfc/rfc677.html}},
	month = {January},
	year = {1975},
}
@inproceedings{distrib-mysql,
	title        = {Distributed Transactions: A Primer with MySQL},
	author       = {Randy Wigginton and Ryan Lowe and Marcos Albe and Fernando Ipar},
	month = {April},
	year         = 2013,
	booktitle    = {MySQL Conference and Expo},
	address      = {Santa Clara, CA},
}
@article{chandra1996reliable,
author = {Chandra, Tushar Deepak and Toueg, Sam},
title = {Unreliable Failure Detectors for Reliable Distributed Systems},
year = {1996},
issue_date = {March 1996},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/226643.226647},
doi = {10.1145/226643.226647},
abstract = {We introduce the concept of unreliable failure detectors and study how they can be used to solve Consensus in asynchronous systems with crash failures. We characterise unreliable failure detectors in terms of two properties—completeness and accuracy. We show that Consensus can be solved even with unreliable failure detectors that make an infinite number of mistakes, and determine which ones can be used to solve Consensus despite any number of crashes, and which ones require a majority of correct processes. We prove that Consensus and Atomic Broadcast are reducible to each other in asynchronous systems with crash failures; thus, the above results also apply to Atomic Broadcast. A companion paper shows that one of the failure detectors introduced here is the weakest failure detector for solving Consensus [Chandra et al. 1992].},
journal = {J. ACM},
month = {mar},
pages = {225–267},
numpages = {43},
keywords = {crash failures, Byzantine Generals' problem, consensus problem, processor failures, partial synchrony, commit problem, atomic broadcast, message passing, fault-tolerance, asynchronous systems, failure detection, agreement problem}
}
@article{byzantine-tolerance-2002,
author = {Castro, Miguel and Liskov, Barbara},
title = {Practical Byzantine Fault Tolerance and Proactive Recovery},
year = {2002},
issue_date = {November 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {4},
issn = {0734-2071},
url = {https://doi.org/10.1145/571637.571640},
doi = {10.1145/571637.571640},
abstract = {Our growing reliance on online services accessible on the Internet demands highly available systems that provide correct service without interruptions. Software bugs, operator mistakes, and malicious attacks are a major cause of service interruptions and they can cause arbitrary behavior, that is, Byzantine faults. This article describes a new replication algorithm, BFT, that can be used to build highly available systems that tolerate Byzantine faults. BFT can be used in practice to implement real services: it performs well, it is safe in asynchronous environments such as the Internet, it incorporates mechanisms to defend against Byzantine-faulty clients, and it recovers replicas proactively. The recovery mechanism allows the algorithm to tolerate any number of faults over the lifetime of the system provided fewer than 1/3 of the replicas become faulty within a small window of vulnerability. BFT has been implemented as a generic program library with a simple interface. We used the library to implement the first Byzantine-fault-tolerant NFS file system, BFS. The BFT library and BFS perform well because the library incorporates several important optimizations, the most important of which is the use of symmetric cryptography to authenticate messages. The performance results show that BFS performs 2\% faster to 24\% slower than production implementations of the NFS protocol that are not replicated. This supports our claim that the BFT library can be used to build practical systems that tolerate Byzantine faults.},
journal = {ACM Trans. Comput. Syst.},
month = {nov},
pages = {398–461},
numpages = {64},
keywords = {asynchronous systems, state machine replication, Byzantine fault tolerance, state transfer, proactive recovery}
}
@inproceedings{vsr1988,
author = {Oki, Brian M. and Liskov, Barbara H.},
title = {Viewstamped Replication: A New Primary Copy Method to Support Highly-Available Distributed Systems},
year = {1988},
isbn = {0897912772},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/62546.62549},
doi = {10.1145/62546.62549},
booktitle = {Proceedings of the Seventh Annual ACM Symposium on Principles of Distributed Computing},
pages = {8–17},
numpages = {10},
location = {Toronto, Ontario, Canada},
series = {PODC '88}
}
@article{paxos1998,
author = {Lamport, Leslie},
title = {The Part-Time Parliament},
year = {1998},
issue_date = {May 1998},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {2},
issn = {0734-2071},
url = {https://doi.org/10.1145/279227.279229},
doi = {10.1145/279227.279229},
abstract = {Recent archaeological discoveries on the island of Paxos reveal that the parliament functioned despite the peripatetic propensity of its part-time legislators. The legislators maintained consistent copies of the parliamentary record, despite their frequent forays from the chamber and the forgetfulness of their messengers. The Paxon parliament's protocol provides a new way of implementing the state machine approach to the design of distributed systems.},
journal = {ACM Trans. Comput. Syst.},
month = {May},
pages = {133–169},
numpages = {37},
keywords = {voting, three-phase commit, state machines}
}
@article{raft2015,
author = {Howard, Heidi and Schwarzkopf, Malte and Madhavapeddy, Anil and Crowcroft, Jon},
title = {Raft Refloated: Do We Have Consensus?},
year = {2015},
issue_date = {January 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {1},
issn = {0163-5980},
url = {https://doi.org/10.1145/2723872.2723876},
doi = {10.1145/2723872.2723876},
abstract = {The Paxos algorithm is famously difficult to reason about and even more so to implement, despite having been synonymous with distributed consensus for over a decade. The recently proposed Raft protocol lays claim to being a new, understandable consensus algorithm, improving on Paxos without making compromises in performance or correctness.In this study, we repeat the Raft authors' performance analysis. We developed a clean-slate implementation of the Raft protocol and built an event-driven simulation framework for prototyping it on experimental topologies. We propose several optimizations to the Raft protocol and demonstrate their effectiveness under contention. Finally, we empirically validate the correctness of the Raft protocol invariants and evaluate Raft's understandability claims.},
journal = {SIGOPS Oper. Syst. Rev.},
month = {Jan},
pages = {12–21},
numpages = {10}
}
@inproceedings{zab2011,
  author={Junqueira, Flavio P. and Reed, Benjamin C. and Serafini, Marco},
  booktitle={2011 IEEE/IFIP 41st International Conference on Dependable Systems \& Networks (DSN)},
  title={Zab: High-performance broadcast for primary-backup systems},
  publisher = {IEEE},
  month = {June},
  year={2011},
  pages={245-256},
  doi={10.1109/DSN.2011.5958223}
}
@article{byzantine-generals,
author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
title = {The Byzantine Generals Problem},
year = {1982},
issue_date = {July 1982},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/357172.357176},
doi = {10.1145/357172.357176},
journal = {ACM Trans. Program. Lang. Syst.},
month = {July},
pages = {382–401},
numpages = {20}
}
// Decomposing Monoliths
@misc{fowler-strangler-fig,
	author       = {Martin Fowler},
	title        = {Strangler Fig},
	howpublished = {\url{https://martinfowler.com/bliki/StranglerFigApplication.html}},
	month        = {August},
	year         = {2024},
}
// Conway's Law
@article{conways-law,
  author = {Conway, Melvin E.},
  title = {How Do Committees Invent?},
  journal = {Datamation},
  keywords = {conways-law organisation communication architecture},
  month = {April},
  year = {1968},
  url = {https://www.melconway.com/research/committees.html},
}
@article{maccormack2012,
title = {Exploring the duality between product and organizational architectures: A test of the “mirroring” hypothesis},
journal = {Research Policy},
volume = {41},
number = {8},
pages = {1309-1324},
year = {2012},
issn = {0048-7333},
doi = {https://doi.org/10.1016/j.respol.2012.04.011},
url = {https://www.sciencedirect.com/science/article/pii/S0048733312001205},
author = {Alan MacCormack and Carliss Baldwin and John Rusnak},
keywords = {Organizational design, Product design, Architecture, Modularity, Open-source software},
abstract = {A variety of academic studies argue that a relationship exists between the structure of an organization and the design of the products that this organization produces. Specifically, products tend to “mirror” the architectures of the organizations in which they are developed. This dynamic occurs because the organization's governance structures, problem solving routines and communication patterns constrain the space in which it searches for new solutions. Such a relationship is important, given that product architecture has been shown to be an important predictor of product performance, product variety, process flexibility and even the path of industry evolution. We explore this relationship in the software industry. Our research takes advantage of a natural experiment, in that we observe products that fulfill the same function being developed by very different organizational forms. At one extreme are commercial software firms, in which the organizational participants are tightly-coupled, with respect to their goals, structure and behavior. At the other, are open source software communities, in which the participants are much more loosely-coupled by comparison. The mirroring hypothesis predicts that these different organizational forms will produce products with distinctly different architectures. Specifically, loosely-coupled organizations will develop more modular designs than tightly-coupled organizations. We test this hypothesis, using a sample of matched-pair products. We find strong evidence to support the mirroring hypothesis. In all of the pairs we examine, the product developed by the loosely-coupled organization is significantly more modular than the product from the tightly-coupled organization. We measure modularity by capturing the level of coupling between a product's components. The magnitude of the differences is substantial—up to a factor of six, in terms of the potential for a design change in one component to propagate to others. Our results have significant managerial implications, in highlighting the impact of organizational design decisions on the technical structure of the artifacts that these organizations subsequently develop.}
}
@misc{platforms-neutralizing-conway,
	author       = {Dan Woods},
	title        = {How Platforms are Neutralizing Conway's Law},
    publisher    = {Forbes},
	howpublished = {\url{https://www.forbes.com/sites/danwoods/2017/08/15/how-platforms-are-neutralizing-conways-law/}},
	month        = {August},
	year         = {2017},
}
// Misc. Articles
@inproceedings{lister-tracing-explaining-writing,
	author = {Lister, Raymond and Fidge, Colin and Teague, Donna},
	title = {Further Evidence of a Relationship between Explaining, Tracing and Writing Skills in Introductory Programming},
	year = {2009},
	isbn = {9781605583815},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1562877.1562930},
	doi = {10.1145/1562877.1562930},
	abstract = {This paper reports on a replication of earlier studies into a possible hierarchy of programming skills. In this study, the students from whom data was collected were at a university that had not provided data for earlier studies. Also, the students were taught the programming language "Python", which had not been used in earlier studies. Thus this study serves as a test of whether the findings in the earlier studies were specific to certain institutions, student cohorts, and programming languages. Also, we used a non-parametric approach to the analysis, rather than the linear approach of earlier studies. Our results are consistent with the earlier studies. We found that students who cannot trace code usually cannot explain code, and also that students who tend to perform reasonably well at code writing tasks have also usually acquired the ability to both trace code and explain code.},
	booktitle = {Proceedings of the 14th Annual ACM SIGCSE Conference on Innovation and Technology in Computer Science Education},
	pages = {161–165},
	numpages = {5},
	keywords = {CS1, comprehension, taxonomy, novice programmers, tracing},
	location = {Paris, France},
	series = {ITiCSE '09}
}
@inproceedings{lister-neo-piagetian,
	author = {Lister, Raymond},
	title = {Concrete and Other Neo-Piagetian Forms of Reasoning in the Novice Programmer},
	year = {2011},
	isbn = {9781920682941},
	publisher = {Australian Computer Society, Inc.},
	address = {AUS},
	abstract = {This paper brings together a number of empirical research results on novice programmers, using a neo-Piagetian theoretical framework. While there already exists literature connecting programming with classical Piagetian theory, in this paper we apply neo-Piagetian theory. Using that neo-Piagetian perspective, we offer an explanation as to why attempts to predict ability for programming via classical Piagetian tests have yielded mixed results. We offer a neo-Piagetian explanation of some of the previously puzzling observations about novice programmers, such as why many of them make little use of diagrams, and why they often manifest a non-systematic approach to writing programs. We also develop the relatively unexplored relationship between concrete operational reasoning and programming, by exploring concepts such as conservation and reversibility.},
	booktitle = {Proceedings of the Thirteenth Australasian Computing Education Conference - Volume 114},
	pages = {9–18},
	numpages = {10},
	keywords = {novice programmer, neo-Piagetian},
	location = {Perth, Australia},
	series = {ACE '11}
}